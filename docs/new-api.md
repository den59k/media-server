# Обновленный список API для медиасервера

### Создание комнаты

Для создания комнаты **POST** запрос на адрес ```/rooms/:room_id```,
где *:room_id* -- ID комнаты, который может как быть предварительно сгенерирован или пропущен --
в этом случае медиасервер сгенерирует его автоматически

В теле запроса также можно передать поле *userId*. В этом случае комната создастся вместе с пользователем. 
Вместе с *userId* можно передать поле *userInfo*, (см. [добавление пользователя в комнату](#добавление-пользователя-в-комнату))

```
Body:
{
    "userId": 1,
    "userInfo": { "contactId": 11 }
}
```

Запрос возвращает id созданной комнаты, а также информацию о добавленном пользователе, если он был создан. 
(см. [добавление пользователя в комнату](#добавление-пользователя-в-комнату))

```
Response: 
{
    "room_id": "a97810e7-b7de-4d22-af4e-5a172746ed55",
    "user_id": "1",
    "users": [],
    "userInfo": { "contactId": 11 }
}
```

### Добавление пользователя в комнату

Для добавления пользователя в комнату используется **POST** запрос на ```/rooms/:room_id/users/:user_id```,
где *:room_id* - ID комнаты, а *:user_id* - ID пользователя 
(ID пользователя генерируется самим бекэнд-сервером заранее, и должно быть уникально для каждого подключения)

Также в параметры можно передать *userInfo*, содержащий любую стороннюю информацию о пользователе (ID контакта, имя и т.д.)

```
Body:
{
    "userInfo": { "contactId": 22 }
}
```

В ответ метод вернет объект *users*, содержащий информацию о всех остальных пользователях в комнате, а также информацию о добавленном пользователе. 
При этом у пользователей-вещателей есть поле *offer* и поле *constraints* (см. [начало вещания пользователем](#начало-вещания-пользователем))

```
Response:
{
    "id": "2",
    "userInfo": {
        "contactId": 22
    },
    "users": [
        {
            "id": "1",
            "userInfo": { "contactId": 11 }
        }
    ]
}
```

### Начало вещания пользователем

Для того, чтобы начать вещание, необходим *offer* от созданного в результате метода *peerConnection.createOffer()*. 
Процесс вещания запускается **POST** запросом на ```/rooms/:room_id/users/:user_id/produce```.

В теле запроса необходимо передать либо поле *offer*, либо поле *constraints*. 
Поле *constraints* содержит два поля *audio* и *video*, и применяется для заглушения какой-либо дорожки.
Если *constraints* не отправлено, оно генерируется исходя из дорожек *offer*

```
Body: 
{
  "offer": { type: "offer", sdp: "..." },
  "constraints": { audio: true, video: true }
}
```

В ответ на запрос приходит *answer*, необходимый для создания подключения вещающему пользователю. Пользователь-вещатель получает *answer* и вызывает метод *peerConnection.setRemoteDescription()*

Вместе с этим в объекте ответа содержится поле *userInfo* с информацией о пользователе-вещателе, и поле *constraints*.

Также в теле ответа содержится массив *outbound*, который содержащит в себе информацию, необходимую для отправки всем остальным пользователям в комнате:
* поле id -- ID пользователя, которому предназначена информация;
* userInfo -- *userInfo* данного пользователя;
* offer -- *offer* для создания нового исходящего подключения с медиасервером.


```
Response:
{
    "answer": { type: "answer", sdp: "..." },
    "id": "1",
    "userInfo": { "contactId": 11 },
    "constraints": {
        "audio": true,
        "video": true
    },
    "outbound": [
        {
            "id": "2",
            "userInfo": { "contactId: 22 },
            "offer": { type: "offer", sdp: "..." }
        }
    ]
}
```

Каждому пользователю отправляется (через WebSocket) нужный ему элемент из *outbound*, а также информация о пользователе вещателе.
Пользователь создает новое подключение (или обновляет текущее, если *offer* с потоком от этого пользователя ему приходил раньше),
вызывает метод *setRemoteDescription* и генрирует ответ методом *createAnswer()*

### Соединение входящего потока с пользователем

Пользователь генерирует свой *answer*, как было описано выше, и отправляет его **POST** 
запросом на ```/rooms/:room_id/users/:user_id/consume```

Тело запроса содержит поле *answer*, и поле *id*. Поле *id* в этом случае -- id пользователя-вещателя.

```
Body:
{
  "id": "1",
  "answer": { type: "answer", sdp: "..." }
}
```

Также можно отправить поле *answers*, содержащее сразу несколько *offer* 
(если планируется одновременно подключить несколько соединений):
```
Body: {
  "answers": [
    { 
      id: "1",
      "answer": { type: "answer", sdp: "..." }
    },
    { 
      id: "2",
      "answer": { type: "answer", sdp: "..." }
    }
  ]
}

```

В ответ придет сообщение об успешном соединении:
```
Response:
{
  "status": "connected"
}

```

### Остановка вещания 

Вещание можно остановить заглушив оба канала, а можно завершить исходящее соединение совсем. 
Для этого используется **DELETE** запрос на ```/rooms/:room_id/users/:user_id/produce```:

```
Body:
{ }
```

В ответе придет информация о завершенном соединении, а также массив outbound, содержащий информацию обо всех остальных пользователях в комнате. По этому массиву всем пользователям отправляется информация о завершении соединения пользователя *id*

```
Response: 
{
    "id": "1",
    "userInfo": {
        "contactId": 11
    },
    "constraints": {
        "audio": false,
        "video": false
    },
    "outbound": [
        {
            "id": "2",
            "userInfo": {
                "contactId": 22
            }
        }
    ]
}
```

### Удаление пользователя из комнаты

Происходит в момент выхода пользователя из комнаты.
Выполняется **DELETE** запросом на адрес ```/rooms/:room_id/users/:user_id```

```
Body:
{ }
```

В ответе приходит массив outbound, содержащий всех остальных пользователей, чтобы уведомить их о выходе пользователе из комнаты

```
Response:
{
    "id": "2",
    "userInfo": {
        "contactId": 22
    },
    "outbound": [
        {
            "id": "1",
            "userInfo": {
                "contactId": 11
            }
        }
    ]
}

```

### Удаление комнаты:

**DELETE** запрос на ```/rooms/:room_id```

Удаляет комнату *room_id*, высвобождая память от всех пользователей. 
Комната также удаляется автоматически в тот момент, когда из неё выходит последний пользователь.

```
Body: 
{ }
```

```
Response
{
  count: number
}
```